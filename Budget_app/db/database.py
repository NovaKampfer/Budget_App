# db/database.py
# --------------------------------------------
# SQLite data layer for EasyBudget (offline)
# - Transactions table (+ optional rule_id if generated by a recurrence)
# - Recurring rules table (every N day/week/month)
# - Idempotent generation with a UNIQUE index
# - Safe migrations for older DBs
# - Faster connection PRAGMAs (WAL, timeout, cache)
# --------------------------------------------

from pathlib import Path
import sqlite3
from datetime import date, timedelta

# ---------- DB location ----------
APP_DIR = Path.home() / ".easybudget_desktop"
APP_DIR.mkdir(parents=True, exist_ok=True)
DB_PATH = APP_DIR / "easybudget.db"

# ---------- Base schema (created if missing) ----------
SCHEMA_BASE = """
PRAGMA foreign_keys = ON;

CREATE TABLE IF NOT EXISTS transactions(
  id INTEGER PRIMARY KEY,
  date TEXT NOT NULL,               -- 'YYYY-MM-DD'
  amount_cents INTEGER NOT NULL,    -- + income, - expense
  note TEXT DEFAULT '',
  rule_id INTEGER                   -- nullable; set for generated rows
);

CREATE INDEX IF NOT EXISTS idx_txn_date ON transactions(date);

CREATE TABLE IF NOT EXISTS recurring_rules(
  id INTEGER PRIMARY KEY,
  start_date TEXT NOT NULL,         -- 'YYYY-MM-DD'
  amount_cents INTEGER NOT NULL,
  note TEXT DEFAULT '',
  every_n INTEGER NOT NULL,         -- e.g., 2
  unit TEXT NOT NULL,               -- 'day' | 'week' | 'month'
  last_generated_date TEXT          -- last date we generated up to (inclusive)
);
"""

_conn = None


def get_conn() -> sqlite3.Connection:
    """Return a cached SQLite connection."""
    global _conn
    if _conn is None:
        _conn = sqlite3.connect(DB_PATH)
        _conn.row_factory = sqlite3.Row
        # --- performance & reliability ---
        _conn.execute("PRAGMA foreign_keys = ON")
        _conn.execute("PRAGMA journal_mode = WAL")
        _conn.execute("PRAGMA synchronous = NORMAL")
        _conn.execute("PRAGMA temp_store = MEMORY")
        _conn.execute("PRAGMA cache_size = -4000")  # ~4MB page cache
        _conn.execute("PRAGMA busy_timeout = 3000")  # wait up to 3s if locked
    return _conn


def migrate_if_needed():
    """
    Ensure schema exists and add missing pieces for older DBs:
    - add 'rule_id' column if missing
    - add UNIQUE index for idempotent generation
    """
    conn = get_conn()
    with conn:
        conn.executescript(SCHEMA_BASE)
        cols = [r["name"]
                for r in conn.execute("PRAGMA table_info('transactions')")]
        if "rule_id" not in cols:
            conn.execute("ALTER TABLE transactions ADD COLUMN rule_id INTEGER")
        # Prevent duplicates for generated rows (manual rows have rule_id NULL)
        conn.execute("""
            CREATE UNIQUE INDEX IF NOT EXISTS ux_txn_unique
            ON transactions(date, amount_cents, note, rule_id)
        """)

# ---------- Basic Transactions API ----------


def insert_txn(date_str: str, cents: int, note: str = "", rule_id=None) -> int:
    """Insert a transaction; return its id (idempotent for generated rows)."""
    conn = get_conn()
    with conn:
        cur = conn.execute(
            "INSERT OR IGNORE INTO transactions(date, amount_cents, note, rule_id) VALUES (?,?,?,?)",
            (date_str, cents, note, rule_id),
        )
        if cur.lastrowid:
            return cur.lastrowid
        # If insert was ignored (duplicate), fetch id of the existing row
        row = conn.execute(
            "SELECT id FROM transactions WHERE date=? AND amount_cents=? AND note=? AND (rule_id IS ? OR rule_id=?)",
            (date_str, cents, note, rule_id, rule_id),
        ).fetchone()
        return row["id"]


def update_txn(txn_id: int, date_str: str, cents: int, note: str = "") -> None:
    conn = get_conn()
    with conn:
        conn.execute(
            "UPDATE transactions SET date=?, amount_cents=?, note=? WHERE id=?",
            (date_str, cents, note, txn_id),
        )


def delete_txn(txn_id: int) -> None:
    conn = get_conn()
    with conn:
        conn.execute("DELETE FROM transactions WHERE id=?", (txn_id,))


def list_by_date(day_iso: str):
    """Return rows for a given date (we need id + rule_id for UI)."""
    conn = get_conn()
    return conn.execute(
        "SELECT id, date, amount_cents, note, rule_id "
        "FROM transactions WHERE date = ? ORDER BY id DESC",
        (day_iso,),
    ).fetchall()


def get_txn(txn_id: int):
    conn = get_conn()
    return conn.execute(
        "SELECT id, date, amount_cents, note, rule_id FROM transactions WHERE id=?",
        (txn_id,),
    ).fetchone()


def balance_on_or_before(day_iso: str) -> int:
    conn = get_conn()
    row = conn.execute(
        "SELECT COALESCE(SUM(amount_cents),0) AS bal FROM transactions WHERE date<=?",
        (day_iso,),
    ).fetchone()
    return row["bal"]

# ---------- Recurrence ----------


def create_rule(start_date: str, amount_cents: int, note: str, every_n: int, unit: str) -> int:
    assert unit in ("day", "week", "month")
    conn = get_conn()
    with conn:
        cur = conn.execute(
            "INSERT INTO recurring_rules(start_date, amount_cents, note, every_n, unit, last_generated_date) "
            "VALUES (?,?,?,?,?,NULL)",
            (start_date, amount_cents, note, every_n, unit),
        )
        return cur.lastrowid


def rules_all():
    """List all recurring rules."""
    return get_conn().execute("SELECT * FROM recurring_rules ORDER BY id").fetchall()


def delete_rule_and_txns(rule_id: int):
    """Delete an entire series and all its generated occurrences."""
    conn = get_conn()
    with conn:
        conn.execute("DELETE FROM transactions WHERE rule_id = ?", (rule_id,))
        conn.execute("DELETE FROM recurring_rules WHERE id = ?", (rule_id,))


def _add_months(d: date, months: int) -> date:
    """Add N months (clamp day to end of month)."""
    y = d.year + (d.month - 1 + months) // 12
    m = (d.month - 1 + months) % 12 + 1
    last_day = [31, 29 if (y % 4 == 0 and (y % 100 != 0 or y % 400 == 0)) else 28,
                31, 30, 31, 30, 31, 31, 30, 31, 30, 31][m - 1]
    return date(y, m, min(d.day, last_day))


def _advance(d: date, every_n: int, unit: str) -> date:
    if unit == "day":
        return d + timedelta(days=every_n)
    if unit == "week":
        return d + timedelta(weeks=every_n)
    if unit == "month":
        return _add_months(d, every_n)
    raise ValueError("invalid unit")


def generate_until(rule_id: int, until_date: str) -> None:
    """
    Generate occurrences for 'rule_id' up to and including 'until_date' (ISO).
    Idempotent due to UNIQUE(date, amount_cents, note, rule_id).
    """
    conn = get_conn()
    r = conn.execute("SELECT * FROM recurring_rules WHERE id=?",
                     (rule_id,)).fetchone()
    if not r:
        return

    start = date.fromisoformat(r["start_date"])
    every_n, unit = r["every_n"], r["unit"]
    amt, note = r["amount_cents"], r["note"]
    horizon = date.fromisoformat(until_date)

    # Start from rule start, or the next slot after last_generated
    cur = start if not r["last_generated_date"] else _advance(
        date.fromisoformat(r["last_generated_date"]), every_n, unit)

    last_created = None
    while cur <= horizon:
        insert_txn(cur.isoformat(), amt, note, rule_id=rule_id)
        last_created = cur
        cur = _advance(cur, every_n, unit)

    if last_created is not None:
        with conn:
            conn.execute(
                "UPDATE recurring_rules SET last_generated_date=? WHERE id=?",
                (last_created.isoformat(), rule_id),
            )


def coalesce_manual_start_into_rule(rule_id: int) -> None:
    """
    If a manual row exists on the rule's start date with same amount/note:
    - attach it to the rule (set rule_id), OR
    - delete it if a generated row already exists,
    so we don't get duplicate first occurrences.
    """
    conn = get_conn()
    r = conn.execute("SELECT * FROM recurring_rules WHERE id=?",
                     (rule_id,)).fetchone()
    if not r:
        return

    start = r["start_date"]
    amt = r["amount_cents"]
    note = r["note"]

    manual = conn.execute(
        "SELECT id FROM transactions WHERE date=? AND amount_cents=? AND note=? AND rule_id IS NULL LIMIT 1",
        (start, amt, note),
    ).fetchone()
    if not manual:
        return

    generated = conn.execute(
        "SELECT id FROM transactions WHERE date=? AND amount_cents=? AND note=? AND rule_id=? LIMIT 1",
        (start, amt, note, rule_id),
    ).fetchone()

    with conn:
        if generated:
            conn.execute("DELETE FROM transactions WHERE id=?",
                         (manual["id"],))
        else:
            conn.execute(
                "UPDATE transactions SET rule_id=? WHERE id=?", (rule_id, manual["id"]))
